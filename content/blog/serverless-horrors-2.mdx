---
title: "Serverless Horrors: Why Serverless Can Bite React/Next.js Teams"
slug: "serverless-horrors-2"
date: "2025-09-07T17:13:30.523Z"
description: "Serverless Horrors collects real-world failures with serverless. Learn what breaks, why, and how to avoid common traps in modern React and Next.js stacks."
tags:
  - "serverless"
  - "nextjs"
  - "react"
  - "performance"
  - "devops"
readingTime: 4
coverImage: "/images/blog/serverless-horrors-2/cover.jpg"
draft: false
---

![]( /images/blog/serverless-horrors/cover.jpg ) Serverless Horrors catalogs what goes wrong with serverless deployments.

It matters for React and Next.js teams building on Vercel, AWS Lambda, or similar platforms.

Serverless promises easy scaling and less ops.

But the site shows how these benefits can hide sharp edges: cold starts, timeouts, missed errors, and debugging pain. ## Why It Matters Serverless is common for Next.js API routes, SSR, and edge functions.

> Note (replace me): Add a 2&ndash;3 line example from your own work or a small repo link.


Many teams deploy React apps this way for fast scaling and lower costs. But serverless has trade-offs.

Performance can drop from cold starts or noisy neighbors.

Debugging is harder when logs are missing or ephemeral. Deployments can fail silently if limits are hit.

Frontend devs, DX owners, and performance leads should care.

Small missteps can tank user experience or break releases. ## Background Serverless Horrors is a curated list of real outages and postmortems from serverless users ([source](https://serverlesshorrors.com/)).

It covers issues like: - Functions timing out under load
- Memory leaks causing OOM kills
- Missed alarms due to incomplete monitoring
- Vendor-specific limits (file size, concurrency)
- Debugging gaps (missing stack traces) Traditional servers give more control: persistent logs, easier debugging, predictable scaling. Serverless shifts these risks to platform defaults and config.

There are no breaking changes or migrations from Serverless Horrors itself&mdash;it&apos;s a reference site. ## Minimal Example: Next.js API Route on Serverless Here&apos;s a minimal Next.js API route that could run into serverless pitfalls: ```
// pages/api/hello.js
export default function handler(req, res) {
  res.status(200).json({ name: &apos;Serverless Horror&apos; });
}
``` Deploy this to Vercel or AWS Lambda with default settings.

If you hit it after a period of inactivity, you may see a cold start delay (100ms&ndash;1s+). Under heavy load, you might hit concurrency or memory limits if not tuned.

No extra flags are needed for basic deployment.

But for production, set up monitoring and error reporting explicitly.

Example curl call:
```
bash
curl https://your-app.vercel.app/api/hello
```
This should return JSON instantly&mdash;unless a cold start happens. ## End-to-End Flow Diagram Idea (Mermaid) ```
mermaid
graph TD;
    User[User Request] --> APIGateway[API Gateway]
    APIGateway --> Lambda[Serverless Function]
    Lambda -->|Cold Start?| ColdStartDelay[Delay]
    Lambda -->|Normal| Handler[API Handler]
    Handler --> Response[Response Sent]
``` This shows how user requests pass through gateways to serverless handlers&mdash;with possible cold start delays. ## Pitfalls to Watch For - **Misconfigurations**: Not setting memory/time limits right can cause silent timeouts or slow responses. - **SSR/Edge Quirks**: Next.js SSR on serverless can have higher latency than static pages.

Edge functions have stricter limits (smaller code size, less Node.js API support). - **Performance Regressions**: Cold starts can spike TTFB (time to first byte).

Heavy dependencies increase package size and startup time. - **Monitoring Gaps**: Default logs may not capture all errors.

Set up external alerting for timeouts or high latency. - **Debugging Pain**: Stack traces may be truncated or missing in production logs.

Reproducing errors locally is harder due to environment differences. - **Vendor Limits**: Each provider has its own max duration, memory cap, and request size&mdash;often lower than traditional servers. - **Silent Failures**: Exceeding concurrency or hitting rate limits may drop requests with little visibility unless you monitor closely. - **Not Documented Yet**: Some edge-case behaviors (e.g., how Vercel handles burst traffic) aren&apos;t fully documented on the site yet. ## Checklist for Safe Serverless Use in React/Next.js Stacks 1.

Measure before/after with Web Vitals (TTFB, FCP). 2.

Ship a tiny demo page using an API route or SSR function. 3.

Add monitoring and alerting for timeouts, errors, and latency spikes. 4.

Plan a rollback path (static fallback or previous deployment). 5.

Share learnings and postmortems internally after incidents.